**# 2017/hack.lu/bit (pwn / 150pts)**


*"No matter what conspiracy theory you believe in - i believe that one wrong bit is enough to rule them all."Ã¹

*"nc flatearth.fluxfingers.net 1744"*


I found this challenge really fun, even if it took me some time to resolve it (still beginning at pwning), plus the fact that I was at work ... :D


We are given a 64bit dynamically stripped binary :

```
-> file bit
bit: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, stripped
```

On which we check for enabled security features :

-> checksec bit
[*] '/home/gov/hack/ctf/hack.lu/pwn_1/bit'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

And then start doing static analysis on it :


```
signed __int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  signed __int64 result; // rax@2
  _BYTE *v4; // rsi@5
  _BYTE *v5; // rax@5
  __int64 canary_check; // rsi@6
  __int64 canary; // [sp+1038h] [bp-8h]@1

  canary = *MK_FP(__FS__, 40LL);
  if ( __isoc99_scanf("%lx:%u", &mem_dst, &value) == 2 )
  {
    if ( value <= 7 )
    {
      mprotect((mem_dst & 0xFFFFFFFFFFFF1000LL), 4096uLL, 7);

      *mem_dst ^= 1 << value;

      mprotect((mem_dst & 0xFFFFFFFFFFFF1000LL), 4096uLL, 5);
      result = 0LL;
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    result = 0xFFFFFFFFLL;
  }
  canary_check = *MK_FP(__FS__, 40LL) ^ canary;
  return result;
}
```


The code generated by IDA is pretty straightforward to understand.
The program wait for the user to write two values separated by a colon => "%lx:%u"

The first value must be an hexadecimal value.
The second must be a 32bit unsigned integer and must be equal or below 7 to reach the "mprotect" branch.


Once corrects values are given, here's what happen :

```
-> echo '400000:1' | strace -e mprotect,read ./bit 
....
....
read(0, "400000:1\n", 4096)             = 9
mprotect(0x400000, 4096, PROT_READ|PROT_WRITE|PROT_EXEC) = 0
mprotect(0x400000, 4096, PROT_READ|PROT_EXEC) = 0
+++ exited with 0 +++

We can see the mprotect call which set the 0x400000 to PROT_READ|PROT_WRITE|PROT_EXEC aka 7 aka RWX.
We also see that the flag is set to RX just after.

But between theses two mprotect call, we have :


```*mem_dst ^= 1 << value;```


so if we entered : 400000:5
It would write (content at address 0x400000) ^ (1 << 5) at 0x400000

(I didn't choose 400000 randomly, 0x400000 is the base address of this executable, and there's no PIE)

```
gef> run
Starting program: /home/gov/hack/ctf/hack.lu/pwn_1/bit 
400000:5

...
...
...

gef> x/1i $pc
=> 0x4006ec:	shl    edi,cl

gef> i r cl
cl             0x5	0x5
```
